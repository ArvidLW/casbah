!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AddToSetOp	query/BarewordOperators.scala	/^trait AddToSetOp extends BarewordQueryOperator {$/;"	t
AllOp	query/CoreOperators.scala	/^trait AllOp extends QueryOperator {$/;"	t
ArrayOps	query/BarewordOperators.scala	/^trait ArrayOps extends PushOp$/;"	t
BSONDecoders	conversions/MonkeyPatches.scala	/^  object BSONDecoders extends Logging {$/;"	o
BSONEncoders	conversions/MonkeyPatches.scala	/^  object BSONEncoders extends Logging {$/;"	o
BSONTransformMonkeyPatch	conversions/MonkeyPatches.scala	/^  object BSONTransformMonkeyPatch extends Logging {$/;"	o
BarewordQueryOperator	query/BarewordOperators.scala	/^trait BarewordQueryOperator extends Logging {$/;"	t
BarewordTargetedQueryOperator	query/BarewordOperators.scala	/^trait BarewordTargetedQueryOperator extends BarewordQueryOperator {$/;"	t
BaseImports	Implicits.scala	/^object BaseImports extends BaseImports$/;"	o
BaseImports	Implicits.scala	/^trait BaseImports {$/;"	t
BasicDBList	Implicits.scala	/^  type BasicDBList = com.mongodb.BasicDBList$/;"	T
BasicDBObject	Implicits.scala	/^  type BasicDBObject = com.mongodb.BasicDBObject$/;"	T
DBAddress	Implicits.scala	/^  type DBAddress = com.mongodb.DBAddress$/;"	T
DBObject	Implicits.scala	/^  type DBObject = com.mongodb.DBObject$/;"	T
DBRef	Implicits.scala	/^  type DBRef = com.mongodb.DBRef$/;"	T
DeregisterConversionHelpers	conversions/ScalaConversions.scala	/^object DeregisterConversionHelpers extends Serializers$/;"	o
DeregisterJodaTimeConversionHelpers	conversions/ScalaConversions.scala	/^object DeregisterJodaTimeConversionHelpers extends JodaDateTimeHelpers {$/;"	o
Deserializers	conversions/ScalaConversions.scala	/^trait Deserializers extends MongoConversionHelper {$/;"	t
ExistsOp	query/CoreOperators.scala	/^trait ExistsOp extends QueryOperator {$/;"	t
FAIL	map_reduce/MapReduceResult.scala	/^  val FAIL = "#FAIL"$/;"	C
FileOp	GridFS.scala	/^  type FileOp = GridFSFile => Unit$/;"	T
FileReadOp	GridFS.scala	/^  type FileReadOp = GridFSDBFile => Unit$/;"	T
FileWriteOp	GridFS.scala	/^  type FileWriteOp = GridFSInputFile => Unit$/;"	T
FluidQueryBarewordOps	query/BarewordOperators.scala	/^trait FluidQueryBarewordOps extends SetOp $/;"	t
FluidQueryOperators	query/CoreOperators.scala	/^trait FluidQueryOperators extends NotEqualsOp $/;"	t
GreaterThanEqualOp	query/CoreOperators.scala	/^trait GreaterThanEqualOp extends QueryOperator {$/;"	t
GreaterThanOp	query/CoreOperators.scala	/^trait GreaterThanOp extends QueryOperator {$/;"	t
GridFS	GridFS.scala	/^class GridFS protected[mongodb](val underlying: MongoGridFS) extends Iterable[GridFSDBFile] with Logging {$/;"	c
GridFS	GridFS.scala	/^object GridFS extends Logging {$/;"	o
GridFS	Implicits.scala	/^  val GridFS = com.novus.casbah.mongodb.gridfs.GridFS$/;"	C
GridFSDBFile	GridFS.scala	/^class GridFSDBFile protected[mongodb](override val underlying: MongoGridFSDBFile) extends GridFSFile {$/;"	c
GridFSFile	GridFS.scala	/^trait GridFSFile extends MongoDBObject with Logging {$/;"	t
GridFSInputFile	GridFS.scala	/^class GridFSInputFile protected[mongodb](override val underlying: MongoGridFSInputFile) extends GridFSFile {$/;"	c
Implicits	Implicits.scala	/^object Implicits extends Implicits$/;"	o
Implicits	Implicits.scala	/^trait Implicits extends FluidQueryBarewordOps {$/;"	t
Imports	Implicits.scala	/^object Imports extends Imports $/;"	o
Imports	Implicits.scala	/^trait Imports extends BaseImports with MongoTypeImports with Implicits $/;"	t
InOp	query/CoreOperators.scala	/^trait InOp extends QueryOperator {$/;"	t
IncOp	query/BarewordOperators.scala	/^trait IncOp extends BarewordQueryOperator {$/;"	t
JSFunction	Implicits.scala	/^  type JSFunction = String$/;"	T
JodaDateTimeDeserializer	conversions/ScalaConversions.scala	/^trait JodaDateTimeDeserializer extends MongoConversionHelper {$/;"	t
JodaDateTimeHelpers	conversions/ScalaConversions.scala	/^trait JodaDateTimeHelpers extends JodaDateTimeSerializer with JodaDateTimeDeserializer $/;"	t
JodaDateTimeSerializer	conversions/ScalaConversions.scala	/^trait JodaDateTimeSerializer extends MongoConversionHelper {$/;"	t
LessThanEqualOp	query/CoreOperators.scala	/^trait LessThanEqualOp extends QueryOperator {$/;"	t
LessThanOp	query/CoreOperators.scala	/^trait LessThanOp extends QueryOperator {$/;"	t
MapReduceCommand	Implicits.scala	/^  type MapReduceCommand = com.novus.casbah.mongodb.map_reduce.MapReduceCommand$/;"	T
MapReduceCommand	Implicits.scala	/^  val MapReduceCommand = com.novus.casbah.mongodb.map_reduce.MapReduceCommand$/;"	C
MapReduceCommand	map_reduce/MapReduceCommand.scala	/^class MapReduceCommand {$/;"	c
MapReduceCommand	map_reduce/MapReduceCommand.scala	/^object MapReduceCommand {$/;"	o
MapReduceError	map_reduce/MapReduceCommand.scala	/^class MapReduceError(msg: String) extends Error("MongoDB Map\/Reduce Error: " + msg)$/;"	c
MapReduceResult	Implicits.scala	/^  type MapReduceResult = com.novus.casbah.mongodb.map_reduce.MapReduceResult$/;"	T
MapReduceResult	map_reduce/MapReduceResult.scala	/^class MapReduceResult(resultObj: DBObject)(implicit db: MongoDB) extends Iterator[DBObject] with Logging {$/;"	c
ModuloOp	query/CoreOperators.scala	/^trait ModuloOp extends QueryOperator {$/;"	t
MongoCollection	Implicits.scala	/^  type MongoCollection = com.novus.casbah.mongodb.MongoCollection$/;"	T
MongoCollection	MongoCollection.scala	/^class MongoCollection(val underlying: DBCollection) extends MongoCollectionWrapper with Iterable[DBObject] {$/;"	c
MongoCollectionWrapper	MongoCollection.scala	/^trait MongoCollectionWrapper extends Logging {$/;"	t
MongoConnection	Implicits.scala	/^  type MongoConnection = com.novus.casbah.mongodb.MongoConnection$/;"	T
MongoConnection	Implicits.scala	/^  val MongoConnection = com.novus.casbah.mongodb.MongoConnection$/;"	C
MongoConnection	MongoConnection.scala	/^class MongoConnection(val underlying: Mongo) {$/;"	c
MongoConnection	MongoConnection.scala	/^object MongoConnection {$/;"	o
MongoConversionHelper	conversions/Helpers.scala	/^trait MongoConversionHelper extends Logging {$/;"	t
MongoCursor	Implicits.scala	/^  type MongoCursor = com.novus.casbah.mongodb.MongoCursor$/;"	T
MongoCursor	MongoCursor.scala	/^class MongoCursor protected[mongodb] (val underlying: DBCursor) extends MongoCursorWrapper[DBObject]  {$/;"	c
MongoCursorWrapper	MongoCursor.scala	/^trait MongoCursorWrapper[A <: DBObject] extends Iterator[A] {$/;"	t
MongoDB	Implicits.scala	/^  type MongoDB = com.novus.casbah.mongodb.MongoDB$/;"	T
MongoDB	MongoDB.scala	/^class MongoDB(val underlying: DB) {$/;"	c
MongoDBAddress	Implicits.scala	/^  val MongoDBAddress = com.novus.casbah.mongodb.MongoDBAddress$/;"	C
MongoDBAddress	MongoConnection.scala	/^object MongoDBAddress { $/;"	o
MongoDBObject	Implicits.scala	/^  type MongoDBObject = com.novus.casbah.mongodb.MongoDBObject$/;"	T
MongoDBObject	Implicits.scala	/^  val MongoDBObject = com.novus.casbah.mongodb.MongoDBObject$/;"	C
MongoDBObject	MongoDBObject.scala	/^object MongoDBObject  {$/;"	o
MongoDBObject	MongoDBObject.scala	/^trait MongoDBObject extends Map[String, AnyRef] with Logging {$/;"	t
MongoTypeImports	Implicits.scala	/^object MongoTypeImports extends MongoTypeImports$/;"	o
MongoTypeImports	Implicits.scala	/^trait MongoTypeImports {$/;"	t
MongoTypedCollection	MongoCollection.scala	/^class MongoTypedCollection[A <: DBObject : Manifest](val underlying: DBCollection) extends Iterable[A] $/;"	c
MongoTypedCursor	MongoCursor.scala	/^class MongoTypedCursor[A <: DBObject : Manifest] protected[mongodb](val underlying: DBCursor) extends MongoCursorWrapper[A]  {$/;"	c
NestingFriendlyQueryOperators	query/CoreOperators.scala	/^trait NestingFriendlyQueryOperators extends LessThanOp$/;"	t
NestingQueryHelper	query/CoreOperators.scala	/^trait NestingQueryHelper extends QueryOperator with Logging {$/;"	t
NotEqualsOp	query/CoreOperators.scala	/^trait NotEqualsOp extends QueryOperator {$/;"	t
NotInOp	query/CoreOperators.scala	/^trait NotInOp extends QueryOperator {$/;"	t
NotOp	query/CoreOperators.scala	/^trait NotOp extends QueryOperator {$/;"	t
NotOpNester	query/CoreOperators.scala	/^  case class NotOpNester(val field: String, _dbObj: Option[DBObject]) extends NestingQueryHelper $/;"	c
ObjectId	Implicits.scala	/^  type ObjectId = org.bson.types.ObjectId$/;"	T
PopOp	query/BarewordOperators.scala	/^trait PopOp extends BarewordQueryOperator {$/;"	t
PullAllOp	query/BarewordOperators.scala	/^trait PullAllOp extends BarewordQueryOperator {$/;"	t
PullOp	query/BarewordOperators.scala	/^trait PullOp extends BarewordQueryOperator {$/;"	t
PushAllOp	query/BarewordOperators.scala	/^trait PushAllOp extends BarewordQueryOperator {$/;"	t
PushOp	query/BarewordOperators.scala	/^trait PushOp extends BarewordQueryOperator {$/;"	t
RegisterConversionHelpers	conversions/ScalaConversions.scala	/^object RegisterConversionHelpers extends Serializers$/;"	o
RegisterJodaTimeConversionHelpers	conversions/ScalaConversions.scala	/^object RegisterJodaTimeConversionHelpers extends JodaDateTimeHelpers {$/;"	o
ScalaDBObject	DeprecatedTypeAliases.scala	/^  type ScalaDBObject = MongoDBObject$/;"	T
ScalaJCollectionSerializer	conversions/ScalaConversions.scala	/^trait ScalaJCollectionSerializer extends MongoConversionHelper {$/;"	t
ScalaMongoCollection	DeprecatedTypeAliases.scala	/^  type ScalaMongoCollection = MongoCollection$/;"	T
ScalaMongoCollectionWrapper	DeprecatedTypeAliases.scala	/^  type ScalaMongoCollectionWrapper = MongoCollectionWrapper$/;"	T
ScalaMongoConn	DeprecatedTypeAliases.scala	/^  object ScalaMongoConn {$/;"	o
ScalaMongoConn	DeprecatedTypeAliases.scala	/^  type ScalaMongoConn = MongoConnection$/;"	T
ScalaMongoCursor	DeprecatedTypeAliases.scala	/^  type ScalaMongoCursor = MongoCursor$/;"	T
ScalaMongoCursorWrapper	DeprecatedTypeAliases.scala	/^  type ScalaMongoCursorWrapper[A <: DBObject] = MongoCursorWrapper[A]$/;"	T
ScalaMongoDB	DeprecatedTypeAliases.scala	/^  type ScalaMongoDB = MongoDB$/;"	T
ScalaRegexSerializer	conversions/ScalaConversions.scala	/^trait ScalaRegexSerializer extends MongoConversionHelper {$/;"	t
ScalaTypedMongoCollection	DeprecatedTypeAliases.scala	/^  type ScalaTypedMongoCollection[A <: DBObject] = MongoTypedCollection[A]$/;"	T
ScalaTypedMongoCursor	DeprecatedTypeAliases.scala	/^  type ScalaTypedMongoCursor[A <: DBObject] = MongoTypedCursor[A]$/;"	T
Serializers	conversions/ScalaConversions.scala	/^trait Serializers extends MongoConversionHelper $/;"	t
SetOp	query/BarewordOperators.scala	/^trait SetOp extends BarewordQueryOperator {$/;"	t
SizeOp	query/CoreOperators.scala	/^trait SizeOp extends QueryOperator {$/;"	t
UnderlyingObj	MongoCollection.scala	/^  type UnderlyingObj = A$/;"	T
UnsetOp	query/BarewordOperators.scala	/^trait UnsetOp extends BarewordQueryOperator {$/;"	t
ValueTestFluidQueryOperators	query/CoreOperators.scala	/^trait ValueTestFluidQueryOperators extends LessThanOp $/;"	t
WhereOp	query/CoreOperators.scala	/^trait WhereOp extends QueryOperator {$/;"	t
_dbObj	query/CoreOperators.scala	/^  val _dbObj: Option[DBObject]$/;"	C
addUser	MongoDB.scala	/^  def addUser(username: String, passwd: String) = underlying.addUser(username, passwd.toArray)$/;"	m
aliases	GridFS.scala	/^  def aliases = underlying.getAliases.asScala$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply() = new MongoConnection(new Mongo())$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply(addr: DBAddress) = new MongoConnection(new Mongo(addr))$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply(addr: DBAddress, options: MongoOptions) = new MongoConnection(new Mongo(addr, options))$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply(host: String) = new MongoConnection(new Mongo(host))$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply(host: String, port: Int) = new MongoConnection(new Mongo(host, port))$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply(left: DBAddress, right: DBAddress) = new MongoConnection(new Mongo(left, right))$/;"	m
apply	DeprecatedTypeAliases.scala	/^    def apply(left: DBAddress, right: DBAddress, options: MongoOptions) = new MongoConnection(new Mongo(left, right, options))$/;"	m
apply	GridFS.scala	/^   def apply(data: Array[Byte])(op: FileWriteOp) = withNewFile(data)(op)$/;"	m
apply	GridFS.scala	/^   def apply(data: scala.io.Source)(op: FileWriteOp) = withNewFile(data)(op)$/;"	m
apply	GridFS.scala	/^   def apply(f: File)(op: FileWriteOp) = withNewFile(f)(op)$/;"	m
apply	GridFS.scala	/^   def apply(in: InputStream)(op: FileWriteOp) = withNewFile(in)(op)$/;"	m
apply	GridFS.scala	/^   def apply(in: InputStream, filename: String)(op: FileWriteOp) = withNewFile(in, filename)(op)$/;"	m
apply	GridFS.scala	/^  def apply(db: MongoDB) = {$/;"	m
apply	GridFS.scala	/^  def apply(db: MongoDB, bucket: String) = { $/;"	m
apply	MongoConnection.scala	/^  def apply() = new MongoConnection(new Mongo())$/;"	m
apply	MongoConnection.scala	/^  def apply(addr: DBAddress) = new MongoConnection(new Mongo(addr))$/;"	m
apply	MongoConnection.scala	/^  def apply(addr: DBAddress, options: MongoOptions) = new MongoConnection(new Mongo(addr, options))$/;"	m
apply	MongoConnection.scala	/^  def apply(dbName: String) = underlying.getDB(dbName).asScala$/;"	m
apply	MongoConnection.scala	/^  def apply(host: String) = new MongoConnection(new Mongo(host))$/;"	m
apply	MongoConnection.scala	/^  def apply(host: String, dbName: String) = new DBAddress(host, dbName)$/;"	m
apply	MongoConnection.scala	/^  def apply(host: String, port: Int) = new MongoConnection(new Mongo(host, port))$/;"	m
apply	MongoConnection.scala	/^  def apply(host: String, port: Int, dbName: String) = $/;"	m
apply	MongoConnection.scala	/^  def apply(left: DBAddress, right: DBAddress) = new MongoConnection(new Mongo(left, right))$/;"	m
apply	MongoConnection.scala	/^  def apply(left: DBAddress, right: DBAddress, options: MongoOptions) = new MongoConnection(new Mongo(left, right, options))$/;"	m
apply	MongoConnection.scala	/^  def apply(other: DBAddress, dbName: String) = new DBAddress(other, dbName)$/;"	m
apply	MongoConnection.scala	/^  def apply(urlFormat: String) = new DBAddress(urlFormat)$/;"	m
apply	MongoDB.scala	/^  def apply(collection: String) = underlying.getCollection(collection).asScala$/;"	m
apply	MongoDB.scala	/^  def apply[A <: DBObject](collection: String, clazz: Class[A])(implicit m: scala.reflect.Manifest[A]) = underlying.getCollection(collection).asScalaTyped(m)$/;"	m
apply	MongoDBObject.scala	/^  def apply[A <: String, B <: Any](elems: (A, B)*) = (newBuilder[A, B] ++= elems).result$/;"	m
apply	conversions/MonkeyPatches.scala	/^    def apply()  = org.bson.BSON._decodingHooks$/;"	m
apply	conversions/MonkeyPatches.scala	/^    def apply() = org.bson.BSON._encodingHooks$/;"	m
apply	conversions/MonkeyPatches.scala	/^    def apply(decodeType: Class[_]) = org.bson.BSON._decodingHooks.get(decodeType) match {$/;"	m
apply	conversions/MonkeyPatches.scala	/^    def apply(encodeType: Class[_]) = org.bson.BSON._encodingHooks.get(encodeType) match {$/;"	m
apply	conversions/ScalaConversions.scala	/^  def apply() = {$/;"	m
apply	map_reduce/MapReduceCommand.scala	/^  def apply(collection: String,$/;"	m
apply	query/BarewordOperators.scala	/^  def apply[A](oper: String)(fields: (String, A)*): DBObject = { $/;"	m
apply	query/BarewordOperators.scala	/^  def apply[A](oper: String)(fields: A*) = {$/;"	m
apply	query/CoreOperators.scala	/^  def apply(target: Any) = { $/;"	m
arityRange	Implicits.scala	/^    val arityRange =  0.until(p.productArity)$/;"	C
asDBObject	Implicits.scala	/^    def asDBObject = map2MongoDBObject(map)$/;"	m
asDBObject	Implicits.scala	/^    def asDBObject = productToMongoDBObject(p)$/;"	m
asDBObject	MongoDBObject.scala	/^  def asDBObject = underlying$/;"	m
asDBObject	map_reduce/MapReduceCommand.scala	/^  def asDBObject = toDBObj $/;"	m
asScala	Implicits.scala	/^    def asScala = new MongoCollection(coll)$/;"	m
asScala	Implicits.scala	/^    def asScala = new MongoConnection(conn)$/;"	m
asScala	Implicits.scala	/^    def asScala = new MongoCursor(cursor)$/;"	m
asScala	Implicits.scala	/^    def asScala = new MongoDB(db)$/;"	m
asScalaTyped	Implicits.scala	/^    def asScalaTyped[A <: DBObject : Manifest] = new MongoTypedCursor[A](cursor)$/;"	m
asScalaTyped	Implicits.scala	/^    def asScalaTyped[A<:DBObject](implicit m: scala.reflect.Manifest[A]) = new MongoTypedCollection[A](coll)(m)$/;"	m
authenticate	MongoDB.scala	/^  def authenticate(username: String, passwd: String) = underlying.authenticate(username, passwd.toArray)$/;"	m
avgValue	MongoCollection.scala	/^  def avgValue(field: String, condition: DBObject) = {$/;"	m
batchSize	MongoCursor.scala	/^  def batchSize(n: Int) = underlying.batchSize(n) asScala$/;"	m
batchSize	MongoCursor.scala	/^  def batchSize(n: Int) = underlying.batchSize(n) asScalaTyped$/;"	m
bldr	query/BarewordOperators.scala	/^    val bldr = MongoDBObject.newBuilder$/;"	C
bucketName	GridFS.scala	/^   def bucketName = underlying.getBucketName$/;"	m
builder	Implicits.scala	/^    val builder = BasicDBObjectBuilder.start$/;"	C
chunkSize	GridFS.scala	/^  def chunkSize = underlying.getChunkSize$/;"	m
clear	MongoDBObject.scala	/^  def clear() { elems = empty }$/;"	m
cmdData	MongoCollection.scala	/^    val cmdData = Map[String, Any]($/;"	C
collection	map_reduce/MapReduceCommand.scala	/^  var collection: String = ""$/;"	l
com.novus.casbah	DeprecatedTypeAliases.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	GridFS.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	Implicits.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	MongoCollection.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	MongoConnection.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	MongoCursor.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	MongoDB.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	MongoDBObject.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	map_reduce/MapReduceCommand.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	map_reduce/MapReduceResult.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	query/BarewordOperators.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah	query/CoreOperators.scala	/^package com.novus.casbah$/;"	p
com.novus.casbah.mongodb	conversions/Helpers.scala	/^package com.novus.casbah.mongodb$/;"	p
com.novus.casbah.mongodb	conversions/ScalaConversions.scala	/^package com.novus.casbah.mongodb$/;"	p
command	MongoDB.scala	/^  def command(cmd: DBObject) = underlying.command(cmd)$/;"	m
connect	MongoConnection.scala	/^  def connect(addr: DBAddress) = new MongoDB(Mongo.connect(addr))$/;"	m
containsField	MongoDBObject.scala	/^  def containsField(s: String) = underlying.containsField(s)$/;"	m
containsKey	MongoDBObject.scala	/^  def containsKey(s: String) = underlying.containsField(s) \/\/ method kept for backwards compatibility$/;"	m
contentType	GridFS.scala	/^  def contentType = underlying.getContentType$/;"	m
contentType_	GridFS.scala	/^  def contentType_=(cT: String) = underlying.setContentType(cT)$/;"	m
conversions	conversions/Helpers.scala	/^package conversions$/;"	p
conversions	conversions/ScalaConversions.scala	/^package conversions$/;"	p
copy	MongoCursor.scala	/^  def copy() = underlying.copy asScala$/;"	m
copy	MongoCursor.scala	/^  def copy() = underlying.copy asScalaTyped$/;"	m
count	GridFS.scala	/^    def count() = fileSet.count$/;"	m
count	MongoCollection.scala	/^  def count = getCount$/;"	m
count	MongoCollection.scala	/^  def count(query: DBObject) = getCount(query)$/;"	m
count	MongoCollection.scala	/^  def count(query: DBObject, fields: DBObject) = getCount(query, fields)$/;"	m
count	MongoCollection.scala	/^  def count(query: DBObject, fields: DBObject) = getCount(query, fields)*\/$/;"	m
count	MongoCursor.scala	/^  def count = underlying.count$/;"	m
createCollection	MongoDB.scala	/^  def createCollection(name: String, o: DBObject) = underlying.createCollection(name, o)$/;"	m
createFile	GridFS.scala	/^   def createFile(data: Array[Byte]): GridFSInputFile = underlying.createFile(data)$/;"	m
createFile	GridFS.scala	/^   def createFile(data: scala.io.Source): GridFSInputFile = throw new UnsupportedOperationException("Currently no support for scala.io.Source")$/;"	m
createFile	GridFS.scala	/^   def createFile(f: File): GridFSInputFile = underlying.createFile(f)$/;"	m
createFile	GridFS.scala	/^   def createFile(in: InputStream): GridFSInputFile = underlying.createFile(in)$/;"	m
createFile	GridFS.scala	/^   def createFile(in: InputStream, filename: String): GridFSInputFile = underlying.createFile(in, filename)$/;"	m
createIndex	MongoCollection.scala	/^  def createIndex(keys: DBObject) = underlying.createIndex(keys)$/;"	m
curr	GridFS.scala	/^    def curr() = new GridFSDBFile(fileSet.curr.asInstanceOf[MongoGridFSDBFile])$/;"	m
curr	MongoCursor.scala	/^  def curr = underlying.curr.asInstanceOf[A]$/;"	m
cursor	map_reduce/MapReduceResult.scala	/^  def cursor = resultHandle.find$/;"	m
dataObj	map_reduce/MapReduceCommand.scala	/^    val dataObj = BasicDBObjectBuilder.start$/;"	C
debugString	MongoConnection.scala	/^  def debugString() = underlying.debugString$/;"	m
distinct	MongoCollection.scala	/^  def distinct(key: String) = underlying.distinct(key).asScala$/;"	m
distinct	MongoCollection.scala	/^  def distinct(key: String, query: DBObject) = underlying.distinct(key, query).asScala$/;"	m
doEval	MongoDB.scala	/^  def doEval(code: String, args: AnyRef*) = underlying.doEval(code, args: _*)$/;"	m
drop	MongoCollection.scala	/^  def drop() = underlying.drop$/;"	m
dropDatabase	MongoConnection.scala	/^  def dropDatabase(dbName: String) = underlying.dropDatabase(dbName)$/;"	m
dropDatabase	MongoDB.scala	/^  def dropDatabase() = underlying.dropDatabase()$/;"	m
dropIndex	MongoCollection.scala	/^  def dropIndex(keys: DBObject) = underlying.dropIndex(keys)$/;"	m
dropIndex	MongoCollection.scala	/^  def dropIndex(name: String) = underlying.dropIndex(name)$/;"	m
dropIndexes	MongoCollection.scala	/^  def dropIndexes() = underlying.dropIndexes$/;"	m
dropIndexes	MongoCollection.scala	/^  def dropIndexes(name: String) = underlying.dropIndexes$/;"	m
dump	conversions/MonkeyPatches.scala	/^    def dump() = {$/;"	m
emit_count	map_reduce/MapReduceResult.scala	/^  val emit_count: Int = if (counts != null) counts.get("emit").toString.toInt else 0\/\/, throw new IllegalArgumentException("Cannot find field 'counts.emit' in Map\/Reduce Results."))$/;"	C
empty	MongoDBObject.scala	/^  def empty = new MongoDBObject { val underlying = new BasicDBObject }$/;"	m
ensureIndex	MongoCollection.scala	/^  def ensureIndex(keys: DBObject) = underlying.ensureIndex(keys)$/;"	m
ensureIndex	MongoCollection.scala	/^  def ensureIndex(keys: DBObject, name: String) = underlying.ensureIndex(keys, name)$/;"	m
ensureIndex	MongoCollection.scala	/^  def ensureIndex(keys: DBObject, name: String, unique: Boolean) = underlying.ensureIndex(keys, name, unique)$/;"	m
entry	query/CoreOperators.scala	/^    val entry = new BasicDBObject(oper, new BasicDBObject(op, target))$/;"	C
err	map_reduce/MapReduceResult.scala	/^  val err = resultObj.get("errmsg")$/;"	C
eval	MongoDB.scala	/^  def eval(code: String, args: AnyRef*) = underlying.eval(code, args: _*)$/;"	m
explain	GridFS.scala	/^    def explain() = fileSet.explain$/;"	m
explain	MongoCursor.scala	/^  def explain = underlying.explain$/;"	m
field	Implicits.scala	/^    val field = left$/;"	C
field	Implicits.scala	/^    val field = nested._1$/;"	C
field	query/CoreOperators.scala	/^  val field = null$/;"	C
field	query/CoreOperators.scala	/^  val field: String$/;"	C
fileSet	GridFS.scala	/^    val fileSet = files$/;"	C
filename	GridFS.scala	/^  def filename = underlying.getFilename$/;"	m
filename_	GridFS.scala	/^  def filename_=(name: String) = underlying.setFilename(name)$/;"	m
files	GridFS.scala	/^   def files = sansJodaTime { underlying.getFileList }$/;"	m
files	GridFS.scala	/^   def files(query: DBObject) = sansJodaTime { underlying.getFileList(query) } $/;"	m
finalizeFunction	map_reduce/MapReduceCommand.scala	/^  var finalizeFunction: Option[JSFunction] = None$/;"	l
find	GridFS.scala	/^   def find(filename: String) = sansJodaTime { underlying.find(filename).asScala }$/;"	m
find	GridFS.scala	/^   def find(id: ObjectId): GridFSDBFile = sansJodaTime { underlying.find(id) }$/;"	m
find	GridFS.scala	/^   def find(query: DBObject) = sansJodaTime { underlying.find(query).asScala }$/;"	m
find	MongoCollection.scala	/^  def find() = underlying.find.asScala$/;"	m
find	MongoCollection.scala	/^  def find() = underlying.find.asScalaTyped$/;"	m
find	MongoCollection.scala	/^  def find(ref: DBObject) = underlying.find(ref) asScala$/;"	m
find	MongoCollection.scala	/^  def find(ref: DBObject) = underlying.find(ref) asScalaTyped$/;"	m
find	MongoCollection.scala	/^  def find(ref: DBObject, fields: DBObject, numToSkip: Int, batchSize: Int) = underlying.find(ref, fields, numToSkip, batchSize) asScala$/;"	m
find	MongoCollection.scala	/^  def find(ref: DBObject, keys: DBObject) = underlying.find(ref, keys) asScala$/;"	m
find	MongoCollection.scala	/^  def find(ref: DBObject, keys: DBObject) = underlying.find(ref, keys) asScalaTyped$/;"	m
findOne	GridFS.scala	/^   def findOne(filename: String): GridFSDBFile = sansJodaTime { underlying.findOne(filename) }$/;"	m
findOne	GridFS.scala	/^   def findOne(id: ObjectId): GridFSDBFile = sansJodaTime { underlying.findOne(id) }$/;"	m
findOne	GridFS.scala	/^   def findOne(query: DBObject): GridFSDBFile = sansJodaTime { underlying.findOne(query) }$/;"	m
findOne	MongoCollection.scala	/^  def findOne() = optWrap(underlying.findOne().asInstanceOf[A])$/;"	m
findOne	MongoCollection.scala	/^  def findOne(): Option[DBObject] = optWrap(underlying.findOne())$/;"	m
findOne	MongoCollection.scala	/^  def findOne(o: DBObject) = optWrap(underlying.findOne(o).asInstanceOf[A])$/;"	m
findOne	MongoCollection.scala	/^  def findOne(o: DBObject): Option[DBObject] = optWrap(underlying.findOne(o))$/;"	m
findOne	MongoCollection.scala	/^  def findOne(o: DBObject): Option[DBObject]$/;"	m
findOne	MongoCollection.scala	/^  def findOne(o: DBObject, fields: DBObject) = optWrap(underlying.findOne(o, fields).asInstanceOf[A])$/;"	m
findOne	MongoCollection.scala	/^  def findOne(o: DBObject, fields: DBObject): Option[DBObject] = optWrap(underlying.findOne(o, fields))$/;"	m
findOne	MongoCollection.scala	/^  def findOne(obj: Object) = optWrap(underlying.findOne(obj).asInstanceOf[A])$/;"	m
findOne	MongoCollection.scala	/^  def findOne(obj: Object): Option[DBObject] = obj match {$/;"	m
findOne	MongoCollection.scala	/^  def findOne(obj: Object, fields: DBObject) = optWrap(underlying.findOne(obj, fields).asInstanceOf[A])$/;"	m
findOne	MongoCollection.scala	/^  def findOne(obj: Object, fields: DBObject): Option[DBObject] =  obj match {$/;"	m
findOneView	MongoCollection.scala	/^  def findOneView[A <% DBObject : Manifest, B <% DBObject : Manifest](o: A, fields: B) = $/;"	m
findOneView	MongoCollection.scala	/^  def findOneView[A <% DBObject : Manifest](o: A) = optWrap(underlying.findOne(o))$/;"	m
forceError	MongoDB.scala	/^  def forceError() = underlying.forceError$/;"	m
fullName	MongoCollection.scala	/^  def fullName = getFullName()$/;"	m
getAddress	MongoConnection.scala	/^  def getAddress = underlying.getAddress$/;"	m
getAs	MongoDBObject.scala	/^  def getAs[A <% AnyRef : Manifest](key: String): Option[A] = {$/;"	m
getCollection	MongoCollection.scala	/^  def getCollection(n: String) = underlying.getCollection(n)$/;"	m
getCollection	MongoDB.scala	/^  def getCollection(name: String) = underlying.getCollection(name)$/;"	m
getCollectionFromFull	MongoDB.scala	/^  def getCollectionFromFull(fullNameSpace: String) = underlying.getCollectionFromFull(fullNameSpace)$/;"	m
getCollectionFromString	MongoDB.scala	/^  def getCollectionFromString(s: String) = underlying.getCollectionFromString(s)$/;"	m
getCollectionNames	MongoDB.scala	/^  def getCollectionNames() = underlying.getCollectionNames().asScala$/;"	m
getConnectPoint	MongoConnection.scala	/^  def getConnectPoint = underlying.getConnectPoint$/;"	m
getCount	MongoCollection.scala	/^  def getCount() = underlying.getCount()$/;"	m
getCount	MongoCollection.scala	/^  def getCount(query: DBObject) = underlying.getCount(query)$/;"	m
getCount	MongoCollection.scala	/^  def getCount(query: DBObject, fields: DBObject) = underlying.getCount(query, fields)$/;"	m
getDB	MongoCollection.scala	/^  def getDB() = underlying.getDB().asScala$/;"	m
getDB	MongoConnection.scala	/^  def getDB(dbName: String) = apply(dbName)$/;"	m
getDatabaseNames	MongoConnection.scala	/^  def getDatabaseNames() = underlying.getDatabaseNames.asScala$/;"	m
getFullName	MongoCollection.scala	/^  def getFullName() = underlying.getFullName$/;"	m
getIndexInfo	MongoCollection.scala	/^  def getIndexInfo() = underlying.getIndexInfo.asScala$/;"	m
getLastError	MongoDB.scala	/^  def getLastError() = underlying.getLastError$/;"	m
getName	MongoCollection.scala	/^  def getName() = underlying.getName$/;"	m
getName	MongoDB.scala	/^  def getName() = underlying.getName$/;"	m
getObjectClass	MongoCollection.scala	/^  def getObjectClass() = underlying.getObjectClass$/;"	m
getPreviousError	MongoDB.scala	/^  def getPreviousError() = underlying.getPreviousError$/;"	m
getSisterDB	MongoDB.scala	/^  def getSisterDB(name: String) = underlying.getSisterDB(name)$/;"	m
getSizes	MongoCursor.scala	/^  def getSizes() = underlying.getSizes asScala$/;"	m
getVersion	MongoConnection.scala	/^  def getVersion() = underlying.getVersion$/;"	m
getWriteConcern	MongoCollection.scala	/^  def getWriteConcern() = underlying.getWriteConcern$/;"	m
getWriteConcern	MongoDB.scala	/^  def getWriteConcern() = underlying.getWriteConcern$/;"	m
gridfs	GridFS.scala	/^package gridfs$/;"	p
group	MongoCollection.scala	/^  def group(key: DBObject, cond: DBObject): ArrayBuffer[DBObject] = group(key, cond, new BasicDBObject, "function(obj, prev) {}")$/;"	m
group	MongoCollection.scala	/^  def group(key: DBObject, cond: DBObject, function: String): ArrayBuffer[DBObject] = group(key, cond, new BasicDBObject, function)$/;"	m
group	MongoCollection.scala	/^  def group(key: DBObject, cond: DBObject, initial: DBObject, reduce: String) = {$/;"	m
group	MongoCollection.scala	/^  def group(key: DBObject, cond: DBObject, initial: DBObject, reduce: String, finalize: String) = {$/;"	m
groupResult	MongoCollection.scala	/^    val groupResult = group(new BasicDBObject,$/;"	C
hasNext	GridFS.scala	/^    def hasNext: Boolean = fileSet.hasNext$/;"	m
hasNext	MongoCursor.scala	/^  def hasNext: Boolean = underlying.hasNext$/;"	m
hasNext	map_reduce/MapReduceResult.scala	/^  def hasNext: Boolean = resultCursor.hasNext$/;"	m
hint	MongoCursor.scala	/^  def hint(indexKeys: DBObject) = underlying.hint(indexKeys) asScala$/;"	m
hint	MongoCursor.scala	/^  def hint(indexKeys: DBObject) = underlying.hint(indexKeys) asScalaTyped$/;"	m
hint	MongoCursor.scala	/^  def hint(indexName: String) = underlying.hint(indexName) asScala$/;"	m
hint	MongoCursor.scala	/^  def hint(indexName: String) = underlying.hint(indexName) asScalaTyped$/;"	m
id	GridFS.scala	/^  def id = underlying.getId$/;"	m
indexInfo	MongoCollection.scala	/^  def indexInfo = getIndexInfo()$/;"	m
initial	MongoCollection.scala	/^    val initial = Map("count" -> 0, "total" -> 0, "avg" -> 0).asDBObject$/;"	C
initial	MongoCollection.scala	/^    val initial = Map("max" -> "").asDBObject$/;"	C
initial	MongoCollection.scala	/^    val initial = Map("min" -> "").asDBObject$/;"	C
input_count	map_reduce/MapReduceResult.scala	/^  val input_count: Int = if (counts != null) counts.get("input").toString.toInt else 0 \/\/, throw new IllegalArgumentException("Cannot find field 'counts.input' in Map\/Reduce Results."))$/;"	C
insert	MongoCollection.scala	/^  def insert(doc: Array[DBObject]) = underlying.insert(doc)$/;"	m
insert	MongoCollection.scala	/^  def insert(doc: DBObject) = underlying.insert(doc)$/;"	m
insert	MongoCollection.scala	/^  def insert(lst: List[DBObject]) = underlying.insert(lst.asJava)$/;"	m
invoc	query/BarewordOperators.scala	/^    val invoc = super.apply(oper)_$/;"	C
isPartialObject	MongoDBObject.scala	/^  def isPartialObject = underlying.isPartialObject$/;"	m
itcount	GridFS.scala	/^    def itcount() = fileSet.itcount()$/;"	m
iterator	GridFS.scala	/^  def iterator = new Iterator[GridFSDBFile] {$/;"	m
iterator	MongoDBObject.scala	/^  def iterator = underlying.toMap.iterator.asInstanceOf[Iterator[(String, Object)]]$/;"	m
jIterator	GridFS.scala	/^    def jIterator() = fileSet.iterator asScala$/;"	m
jIterator	MongoCursor.scala	/^  def jIterator() = underlying.iterator asScala$/;"	m
jsScope	map_reduce/MapReduceCommand.scala	/^  var jsScope: Option[String] = None$/;"	l
keepTemp	map_reduce/MapReduceCommand.scala	/^  var keepTemp = false \/\/ moot if outputCollection is specific$/;"	l
lastError	MongoCollection.scala	/^  def lastError = underlying.getDB.getLastError$/;"	m
length	GridFS.scala	/^  def length = underlying.getLength$/;"	m
limit	MongoCursor.scala	/^  def limit(n: Int) = underlying.limit(n) asScala$/;"	m
limit	MongoCursor.scala	/^  def limit(n: Int) = underlying.limit(n) asScalaTyped$/;"	m
m	MongoCollection.scala	/^  val m = manifest[A]$/;"	C
mapFunction	map_reduce/MapReduceCommand.scala	/^  var mapFunction: JSFunction = ""$/;"	l
mapReduce	MongoCollection.scala	/^  def mapReduce(command: MapReduceCommand): MapReduceResult  = {$/;"	m
mapReduce	MongoCollection.scala	/^  def mapReduce(mapFunction: JSFunction, reduceFunction: JSFunction, outputCollection: Option[String] = None,$/;"	m
mapReduce	MongoDB.scala	/^  def mapReduce(cmd: MapReduceCommand): MapReduceResult  = {$/;"	m
map_reduce	map_reduce/MapReduceCommand.scala	/^package map_reduce$/;"	p
map_reduce	map_reduce/MapReduceResult.scala	/^package map_reduce$/;"	p
markAsPartialObject	MongoDBObject.scala	/^  def markAsPartialObject = underlying.markAsPartialObject$/;"	m
maxDate	MongoCollection.scala	/^  def maxDate(field: String, condition: DBObject) = {$/;"	m
maxValue	MongoCollection.scala	/^  def maxValue(field: String, condition: DBObject) = {$/;"	m
md5	GridFS.scala	/^  def md5: String = underlying.getMD5$/;"	m
metaData	GridFS.scala	/^  def metaData: DBObject = underlying.getMetaData$/;"	m
minDate	MongoCollection.scala	/^  def minDate(field: String, condition: DBObject) = {$/;"	m
minValue	MongoCollection.scala	/^  def minValue(field: String, condition: DBObject) = {$/;"	m
mongodb	GridFS.scala	/^package mongodb$/;"	p
mongodb	Implicits.scala	/^package mongodb$/;"	p
mongodb	MongoCollection.scala	/^package mongodb$/;"	p
mongodb	MongoConnection.scala	/^package mongodb$/;"	p
mongodb	MongoCursor.scala	/^package mongodb$/;"	p
mongodb	MongoDB.scala	/^package mongodb$/;"	p
mongodb	MongoDBObject.scala	/^package mongodb$/;"	p
mongodb	map_reduce/MapReduceCommand.scala	/^package mongodb$/;"	p
mongodb	map_reduce/MapReduceResult.scala	/^package mongodb$/;"	p
mongodb	query/BarewordOperators.scala	/^package mongodb$/;"	p
mongodb	query/CoreOperators.scala	/^package mongodb$/;"	p
mrc	map_reduce/MapReduceCommand.scala	/^      val mrc = new MapReduceCommand()$/;"	C
mrc	map_reduce/MapReduceCommand.scala	/^    val mrc = new MapReduceCommand()$/;"	C
name	MongoCollection.scala	/^  def name = getName()$/;"	m
name	MongoDB.scala	/^  def name = getName$/;"	m
newBuilder	MongoDBObject.scala	/^  def newBuilder[A <: String, B <: Any]: MongoDBObjectBuilder = new MongoDBObjectBuilder$/;"	m
next	GridFS.scala	/^    def next() = new GridFSDBFile(fileSet.next.asInstanceOf[MongoGridFSDBFile])$/;"	m
next	MongoCursor.scala	/^  def next: A = underlying.next.asInstanceOf[A]$/;"	m
next	map_reduce/MapReduceResult.scala	/^  def next(): DBObject = resultCursor.next$/;"	m
numChunks	GridFS.scala	/^  def numChunks: Int = underlying.numChunks$/;"	m
numGetMores	GridFS.scala	/^    def numGetMores() = fileSet.numGetMores$/;"	m
numGetMores	MongoCursor.scala	/^  def numGetMores = underlying.numGetMores$/;"	m
numSeen	GridFS.scala	/^    def numSeen() =  fileSet.numSeen$/;"	m
numSeen	MongoCursor.scala	/^  def numSeen =  underlying.numSeen$/;"	m
object	DeprecatedTypeAliases.scala	/^package object mongodb {$/;"	p
objectClass	MongoCollection.scala	/^  def objectClass = getObjectClass()$/;"	m
ok	map_reduce/MapReduceResult.scala	/^  val ok = if (resultObj.get("ok") == 1) true else false$/;"	C
opMap	query/CoreOperators.scala	/^      val opMap = BasicDBObjectBuilder.start(op, target).get$/;"	C
oper	query/CoreOperators.scala	/^    val oper = "$not"$/;"	C
oper	query/CoreOperators.scala	/^  val oper: String$/;"	C
optWrap	MongoCollection.scala	/^  def optWrap[A <% DBObject](obj: A): Option[A] = {$/;"	m
org.bson	conversions/MonkeyPatches.scala	/^package org.bson {$/;"	p
outputCollection	map_reduce/MapReduceCommand.scala	/^  var outputCollection: Option[String] = None$/;"	l
output_count	map_reduce/MapReduceResult.scala	/^  val output_count: Int = if (counts != null) counts.get("output").toString.toInt else 0\/\/throw new IllegalArgumentException("Cannot find field 'counts.output' in Map\/Reduce Results."))$/;"	C
partialObject	MongoDBObject.scala	/^  def partialObject = isPartialObject$/;"	m
productToMongoDBObject	Implicits.scala	/^  def productToMongoDBObject(p: Product): DBObject = {$/;"	m
putAll	MongoDBObject.scala	/^  def putAll(m: Map[_, _]) = underlying.putAll(m)$/;"	m
putAll	MongoDBObject.scala	/^  def putAll(m: java.util.Map[_, _]) = underlying.putAll(m)$/;"	m
putAll	MongoDBObject.scala	/^  def putAll(o: DBObject) = underlying.putAll(o)$/;"	m
query	map_reduce/MapReduceCommand.scala	/^  var query: Option[DBObject] = None$/;"	l
query	query/BarewordOperators.scala	/^package query$/;"	p
query	query/CoreOperators.scala	/^package query$/;"	p
reduceFunction	map_reduce/MapReduceCommand.scala	/^  var reduceFunction: JSFunction = ""$/;"	l
register	conversions/Helpers.scala	/^  def register() = {$/;"	m
remove	GridFS.scala	/^    def remove() = fileSet.remove$/;"	m
remove	GridFS.scala	/^   def remove(filename: String) = underlying.remove(filename)$/;"	m
remove	GridFS.scala	/^   def remove(id: ObjectId) = underlying.remove(id)$/;"	m
remove	GridFS.scala	/^   def remove(query: DBObject) = underlying.remove(query)$/;"	m
remove	MongoCollection.scala	/^  def remove(o: DBObject) = underlying.remove(o)$/;"	m
remove	MongoCursor.scala	/^  def remove() = underlying.remove$/;"	m
remove	conversions/MonkeyPatches.scala	/^    def remove(decodeType: Class[_]) = apply(decodeType) match {$/;"	m
remove	conversions/MonkeyPatches.scala	/^    def remove(encodeType: Class[_]) =  apply(encodeType) match {$/;"	m
removeField	MongoDBObject.scala	/^  def removeField(key: String) = underlying.removeField(key)$/;"	m
rename	MongoCollection.scala	/^  def rename(newName: String) = underlying.rename(newName)$/;"	m
requestDone	MongoDB.scala	/^  def requestDone() = underlying.requestDone$/;"	m
requestEnsureConnection	MongoDB.scala	/^  def requestEnsureConnection() = underlying.requestEnsureConnection$/;"	m
requestStart	MongoDB.scala	/^  def requestStart() = underlying.requestStart$/;"	m
resetError	MongoDB.scala	/^  def resetError() = underlying.resetError$/;"	m
resetIndexCache	MongoCollection.scala	/^  def resetIndexCache() = underlying.resetIndexCache()$/;"	m
resetIndexCache	MongoDB.scala	/^  def resetIndexCache() = underlying.resetIndexCache$/;"	m
result	MongoCollection.scala	/^    val result = getDB.command(BasicDBObjectBuilder.start("group", cmdData).get)$/;"	C
result	MongoCollection.scala	/^    val result = getDB.command(command.asDBObject)$/;"	C
result	MongoCollection.scala	/^    val result = underlying.group(key, cond, initial, reduce).toMap.asScala$/;"	C
result	MongoDB.scala	/^    val result = command(cmd.asDBObject)$/;"	C
result	MongoDBObject.scala	/^  def result = new MongoDBObject { val underlying = elems.get }$/;"	m
result	map_reduce/MapReduceResult.scala	/^  val result = if (resultObj.containsField("result"))  {$/;"	C
resultHandle	map_reduce/MapReduceResult.scala	/^  val resultHandle = db(result.toString)$/;"	C
ret	GridFS.scala	/^        val ret = op$/;"	C
sansJodaTime	GridFS.scala	/^   def sansJodaTime[T](op: => T) = org.bson.BSONDecoders(classOf[java.util.Date]) match {   $/;"	m
save	GridFS.scala	/^  def save = underlying.save$/;"	m
save	MongoCollection.scala	/^  def save(jo: DBObject) = underlying.save(jo)$/;"	m
scala	conversions/ScalaConversions.scala	/^package scala$/;"	p
setHintFields	MongoCollection.scala	/^  def setHintFields(lst: List[DBObject]) = underlying.setHintFields(lst.asJava)$/;"	m
setInternalClass	MongoCollection.scala	/^  def setInternalClass(path: String, c: Class[_]) = underlying.setInternalClass(path, c)$/;"	m
setObjectClass	MongoCollection.scala	/^  def setObjectClass[A <: DBObject : Manifest](c: Class[A]) = {$/;"	m
setReadOnly	MongoDB.scala	/^  def setReadOnly(b: Boolean) = underlying.setReadOnly(b)$/;"	m
setWriteConcern	MongoCollection.scala	/^  def setWriteConcern(concern: DB.WriteConcern) = underlying.setWriteConcern(concern)$/;"	m
setWriteConcern	MongoDB.scala	/^  def setWriteConcern(concern: DB.WriteConcern) = underlying.setWriteConcern(concern)$/;"	m
skip	MongoCursor.scala	/^  def skip(n: Int) = underlying.skip(n) asScala$/;"	m
skip	MongoCursor.scala	/^  def skip(n: Int) = underlying.skip(n) asScalaTyped$/;"	m
snapshot	MongoCursor.scala	/^  def snapshot() = underlying.snapshot() asScala$/;"	m
snapshot	MongoCursor.scala	/^  def snapshot() = underlying.snapshot() asScalaTyped$/;"	m
sort	MongoCursor.scala	/^  def sort(orderBy: DBObject) = underlying.sort(orderBy) asScala$/;"	m
sort	MongoCursor.scala	/^  def sort(orderBy: DBObject) = underlying.sort(orderBy) asScalaTyped$/;"	m
sort	map_reduce/MapReduceCommand.scala	/^  var sort: Option[DBObject] = None$/;"	l
sort	map_reduce/MapReduceResult.scala	/^  def sort(orderBy: DBObject): MongoCursor = resultHandle.find.sort(orderBy)$/;"	m
success	map_reduce/MapReduceResult.scala	/^  val success = err match {$/;"	C
t	Implicits.scala	/^        val t = p.asInstanceOf[Tuple2[String, Any]]$/;"	C
t	Implicits.scala	/^        val t = x.asInstanceOf[Tuple2[String, Any]]$/;"	C
timeMillis	map_reduce/MapReduceResult.scala	/^  val timeMillis = if (counts != null) resultObj.get("timeMillis").toString.toInt else -1 \/\/throw new IllegalArgumentException("Cannot find field 'timeMillis' in Map\/Reduce Results."))$/;"	C
toArray	MongoCursor.scala	/^  def toArray() = {$/;"	m
toArray	MongoCursor.scala	/^  def toArray(min: Int) = {$/;"	m
toDBObj	map_reduce/MapReduceCommand.scala	/^  def toDBObj = {$/;"	m
toMap	MongoDBObject.scala	/^  def toMap = underlying.toMap$/;"	m
transform	conversions/ScalaConversions.scala	/^    def transform(o: AnyRef): AnyRef = o match {$/;"	m
underlying	GridFS.scala	/^  val underlying: MongoGridFSFile$/;"	C
underlying	MongoCollection.scala	/^  val underlying: DBCollection$/;"	C
underlying	MongoCursor.scala	/^  val underlying: DBCursor$/;"	C
underlying	MongoDBObject.scala	/^  val underlying: DBObject$/;"	C
unregister	conversions/Helpers.scala	/^  def unregister() = {$/;"	m
update	MongoCollection.scala	/^  def update(q: DBObject, o: DBObject) = underlying.update(q, o)$/;"	m
update	MongoCollection.scala	/^  def update(q: DBObject, o: DBObject, upsert: Boolean, multi: Boolean) = underlying.update(q, o, upsert, multi)$/;"	m
updateMulti	MongoCollection.scala	/^  def updateMulti(q: DBObject, o: DBObject) = underlying.updateMulti(q, o)$/;"	m
uploadDate	GridFS.scala	/^  def uploadDate = underlying.getUploadDate$/;"	m
validate	GridFS.scala	/^  def validate = underlying.validate$/;"	m
verbose	map_reduce/MapReduceCommand.scala	/^  var verbose = true \/\/ provides statistics on job execution$/;"	l
withNewFile	GridFS.scala	/^   def withNewFile(data: Array[Byte])(op: FileWriteOp) { loan(createFile(data))({ fh => op(fh); fh.save } ) }$/;"	m
withNewFile	GridFS.scala	/^   def withNewFile(data: scala.io.Source)(op: FileWriteOp) = throw new UnsupportedOperationException("Currently no support for scala.io.Source")$/;"	m
withNewFile	GridFS.scala	/^   def withNewFile(f: File)(op: FileWriteOp) { loan(createFile(f))({ fh => op(fh); fh.save }) }$/;"	m
withNewFile	GridFS.scala	/^   def withNewFile(in: InputStream)(op: FileWriteOp) { loan(createFile(in))({ fh => op(fh); fh.save }) }$/;"	m
withNewFile	GridFS.scala	/^   def withNewFile(in: InputStream, filename: String)(op: FileWriteOp) { loan(createFile(in, filename))({ fh => op(fh); fh.save }) }$/;"	m
writeConcern	MongoCollection.scala	/^  def writeConcern = getWriteConcern$/;"	m
x	Implicits.scala	/^      val x = p.productElement(i)$/;"	C
